const CreateRawChannel=()=>({pos:0,playing:!1,sample:null,speed:0,loops:0});class SfxRawProcessor extends AudioWorkletProcessor{_ready=!1;_playing=!1;_channels=new Array(4).fill(null).map((()=>({pos:0,playing:!1,sample:null,speed:0,loops:0})));_mixingRate=0;constructor(){super(),this.port.onmessage=this.handleMessage.bind(this)}handleMessage(e){switch(e.data.message){case"init":console.log("[soundProcessor] setting mixingRate to",e.data.mixingRate),this._ready=!0,this._mixingRate=e.data.mixingRate;break;case"play":{const{sound:s,channel:t}=e.data;this.play(s,t),this._playing=!0;break}case"stop":{const{channel:s}=e.data;this._channels[s].playing=!1}}}play(e,s){const t=this._channels[s];t.playing=!0,t.sample=e.sample,t.pos=0,t.speed=e.freq/this._mixingRate,t.loops=e.loops,t.volume=e.volume}mixChannels(e,s){for(let t=0;t<s;++t)for(let s=0;s<this._channels.length;++s){const a=this._channels[s];if(a.playing){const s=a.sample[Math.floor(a.pos)]*a.volume/63;e[0][t]+=s/128,a.pos+=a.speed,a.pos>a.sample.length-1&&(-1===a.loops?a.pos=a.sample.length-a.pos:a.playing=!1)}}}process(e,s,t){return this._ready&&this.mixChannels(s[0],s[0][0].length),!0}}class Frac{static BITS=16;static MASK=(1<<Frac.BITS)-1;inc=0;offset=0;reset(e,s){this.inc=Math.floor((e<<Frac.BITS)/s),this.offset=0}getInt(){return this.offset>>Frac.BITS}getFrac(){return this.offset&Frac.MASK}interpolate(e,s){const t=this.getFrac();return e*(Frac.MASK-t)+s*t>>Frac.BITS}}let prevL=0,prevR=0;function nr(e,s,t){let a=0,o=0;for(let l=0;l<s;++l){const s=e[a]>>1;a++,t[o]=s+prevL,t[o]>128||t[o],o++,prevL=s;const l=e[a]>>1;a++,t[o]=l+prevR,o++,prevR=l}}const CreateChannel=()=>({sampleData:null,sampleLen:0,sampleLoopPos:0,sampleLoopLen:0,volume:0,pos:new Frac}),CreateSfxPattern=()=>({note_1:0,note_2:0,sampleStart:0,sampleBuffer:null,sampleLen:0,loopPos:0,loopLen:0,sampleVolume:0}),F32Max=e=>e>1?1:e<-1?-1:e;class SfxPlayerProcessor extends AudioWorkletProcessor{_ready=!1;_delay=0;_resNum=0;_sfxMod=null;_playing=!1;_rate=0;_samplesLeft=0;_channels=new Array(4).fill(null);constructor(){super(),this.port.onmessage=this.handleMessage.bind(this)}handleMessage(e){switch(e.data.message){case"init":console.log("[soundProcessor] setting mixingRate to",e.data.mixingRate),this._ready=!0;break;case"play":const{mixingRate:s}=e.data;this.play(s);break;case"load":{const{sfxMod:s,delay:t}=e.data;this._delay=t,this.load(s);break}case"stop":this.stop();break;case"start":this.start();break;case"setEventsDelay":{const{delay:s}=e.data;this._delay=s;break}}}postMessage(e){this.port.postMessage(e)}load(e){this._sfxMod=e}start(){this._sfxMod.curPos=0}stop(){this._playing=!1,this._resNum=0}play(e){this._playing=!0,this._rate=e,this._samplesLeft=0,this._channels=this._channels.map((()=>({sampleData:null,sampleLen:0,sampleLoopPos:0,sampleLoopLen:0,volume:0,pos:new Frac})))}mixSfxPlayer(e,s,t){const a=new Int8Array(2*t).fill(0);this.readSamples(a,t);for(let e=0;e<t;++e)s[0][e]=F32Max(a[2*e]/128),s[1][e]=F32Max(a[2*e+1]/128)}readSamples(e,s){if(0===this._delay)e.fill(0,0,2*s);else{const t=new Int8Array(2*s);this.mixSamples(t,s),nr(t,s,e)}}mixSamples(e,s){e.fill(0,0,2*s);const t=Math.floor(this._rate/Math.floor(1e3/this._delay));let a=0;for(;0!==s;){0===this._samplesLeft&&(this.handleEvents(),this._samplesLeft=t);let o=this._samplesLeft;o>s&&(o=s),this._samplesLeft-=o,s-=o;for(let s=0;s<o;++s)e[a]=this.mixChannel(e[a],this._channels[0]),e[a]=this.mixChannel(e[a],this._channels[3]),a++,e[a]=this.mixChannel(e[a],this._channels[1]),e[a]=this.mixChannel(e[a],this._channels[2]),a++}}mixChannel(e,s){if(0===s.sampleLen)return e;const t=s.pos.offset>>Frac.BITS>>0;s.pos.offset+=s.pos.inc;let a=t+1;if(0!==s.sampleLoopLen)t===s.sampleLoopPos+s.sampleLoopLen-1&&(a=s.sampleLoopPos,s.pos.offset=a<<Frac.BITS>>0);else if(t===s.sampleLen-1)return s.sampleLen=0,e;let o=s.pos.interpolate(s.sampleData[t]<<24>>24,s.sampleData[a]<<24>>24);return o=e+(o*s.volume/64>>0),o<-128?o=-128:o>127&&(o=127),o}handleEvents(){let e=this._sfxMod.orderTable[this._sfxMod.curOrder],s=this._sfxMod.data.byteOffset+this._sfxMod.curPos+1024*e;for(let e=0;e<4;++e)this.handlePattern(e,new DataView(this._sfxMod.data.buffer,s)),s+=4;this._sfxMod.curPos+=16,this._sfxMod.curPos>=1024&&(this._sfxMod.curPos=0,e=this._sfxMod.curOrder+1,e===this._sfxMod.numOrder&&(this._resNum=0,this._playing=!1),this._sfxMod.curOrder=e)}handlePattern(e,s){const t={note_1:0,note_2:0,sampleStart:0,sampleBuffer:null,sampleLen:0,loopPos:0,loopLen:0,sampleVolume:0};if(t.note_1=s.getUint16(),t.note_2=s.getUint16(2),65533!==t.note_1){const s=(61440&t.note_2)>>12>>0;if(0!==s){const a=this._sfxMod.samples[s-1].data;if(null!==a){t.sampleVolume=this._sfxMod.samples[s-1].volume,t.sampleStart=8,t.sampleBuffer=a,t.sampleLen=2*new DataView(a.buffer,a.byteOffset).getUint16();const o=2*new DataView(a.buffer,a.byteOffset).getUint16(2);0!==o?(t.loopPos=t.sampleLen,t.loopLen=o):(t.loopPos=0,t.loopLen=0);let l=t.sampleVolume;const n=(3840&t.note_2)>>8>>0;5===n?(l+=(255&t.note_2)>>0,l>63&&(l=63)):6===n&&(l-=255&t.note_2,l<0&&(l=0)),this._channels[e].volume=l,t.sampleVolume=l}}}if(65533===t.note_1)this.postMessage({message:"syncVar",variable:244,value:t.note_2});else if(0!==t.note_1)if(65534===t.note_1)this._channels[e].sampleLen=0;else if(null!==t.sampleBuffer){(t.note_1<55||t.note_1>=4096)&&console.error(`Assertion failed: ${t.note_1.toString(16)} >= 0x37 && ${t.note_1.toString(16)} < 0x1000`);const s=Math.floor(7159092/(2*t.note_1)),a=this._channels[e];a.sampleData=new Uint8Array(t.sampleBuffer.buffer,t.sampleBuffer.byteOffset+t.sampleStart),a.sampleLen=t.sampleLen,a.sampleLoopPos=t.loopPos,a.sampleLoopLen=t.loopLen,a.volume=t.sampleVolume,a.pos.offset=0,a.pos.inc=Math.floor((s<<Frac.BITS)/this._rate)}}process(e,s){return this._ready&&this._playing&&this.mixSfxPlayer(e[0],s[0],s[0][0].length),!0}}registerProcessor("sfxplayer-processor",SfxPlayerProcessor),registerProcessor("sfxraw-processor",SfxRawProcessor);